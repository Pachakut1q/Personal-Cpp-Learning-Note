### 小端模式  
(数据的高低位：从右往左即低位到高位)  
数据的低位放在低地址空间，数据的高位放在高地址空间  
在现代通用计算领域中，基本上都采用小端存储模式。小端更便于计算机的操作，地址增加和个十百千万的增加是一致的。
### 大端模式
数据的高位放在低地址空间，数据的低位放在高地址空间  
大端其实和人的直观比较符合，从存储的低地址向高地址看去就是原先的数
 
如果我们创建这样一段代码  
Visual Studio 2022 
```
int main()
{
	char var[5] = "test";
	int a = 100000;
	std::cin.get();
	return 0;
}
```
再打上断点进入调试模式，在watch窗口追踪var和a的地址  
![屏幕截图 2025-03-09 170148](https://github.com/user-attachments/assets/9d4cab31-e5ff-4740-b8d7-6784e60d593e)  
  
打开内存窗口（地址值以十六进制表示），首先定位到整型a的地址  
![屏幕截图 2025-03-09 170616](https://github.com/user-attachments/assets/903eec0a-ec40-44e6-bd57-885c5aee9f29)  
100000=0x0186A0，可以清晰地看到代表低地址的A0被存储在内存中的低地址，高地址的01在内存的高地址。这是小段存储模式。  
  
再定位到数组var的地址  
![屏幕截图 2025-03-09 170457](https://github.com/user-attachments/assets/c0fcce95-1a8a-49cd-a2ba-70a2554698c4)  
字符“t”的十六进制是0x74，“e”是0x65，最后00代表着字符串的最后一位结束符/0  
起初我感到奇怪，var[0]（“t”）在低地址，var[4]（“/0”）在高地址，这不成了大端表示了吗。  
其实道理很简单，数组在内存中按声明顺序连续存储，这种顺序与CPU字节序无关，因为每个字符仅占1字节，无需拆分。不存在前后矛盾。
